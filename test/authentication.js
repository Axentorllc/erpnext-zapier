/*
Zapier App to automate your ERPNext CRM.
Copyright (c) 2018 Raffael Meyer <raffael@alyf.de>
Copyright (c) 2019 Dokos SAS

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

'use strict';

require('should');
const zapier = require('zapier-platform-core');
const App = require('../index');
const nock = require('nock');

const {
  CLIENT_ID,
  BASE_URL,
  OAUTH_AUTHORIZE_ENDPOINT,
  OAUTH_TOKEN_ENDPOINT,
  OAUTH_TEST_ENDPOINT,
} = require('../constants');

const appTester = zapier.createAppTester(App);
zapier.tools.env.inject();

describe('oAuth', () => {
  before(() => {
    // Run `source test/.env` before running `zapier test`.
    // It's a good idea to store your Client ID and Secret in the environment rather than in code.
    // This works locally via the `export` shell command and in production by using `zapier env`
  });

  it('generates an authorize URL', () => {
    const bundle = {
      // In production, these will be generated by Zapier and set automatically
      inputData: {
        state: '4444',
        BASE_URL: BASE_URL,
        CLIENT_ID: CLIENT_ID,
        CLIENT_SECRET: process.env.CLIENT_SECRET,
        redirect_uri: process.env.REDIRECT_URI,
      },
    };

    return appTester(App.authentication.oauth2Config.authorizeUrl, bundle).then(
      authorizeUrl => {
        authorizeUrl.should.eql(
          `${BASE_URL + OAUTH_AUTHORIZE_ENDPOINT}?client_id=${CLIENT_ID}` +
            `&state=${bundle.inputData.state}&response_type=code&scope=all` +
            `&redirect_uri=${encodeURIComponent(bundle.inputData.redirect_uri)}`
        );
      }
    );
  });

  it('can fetch an access token', () => {
    const bundle = {
      inputData: {
        // In production, Zapier passes along whatever code your API set in the query params when it redirects
        // the user's browser to the `redirect_uri`
        code: 'one_time_code',
        state: '4444',
        BASE_URL: BASE_URL,
        CLIENT_ID: CLIENT_ID,
        CLIENT_SECRET: process.env.CLIENT_SECRET,
        redirect_uri: process.env.REDIRECT_URI,
      },
    };

    nock(BASE_URL, {
      reqheaders: {
        'content-type': ['application/x-www-form-urlencoded'],
      },
    })
      .post(OAUTH_TOKEN_ENDPOINT, {
        code: bundle.inputData.code,
        client_id: bundle.inputData.CLIENT_ID,
        client_secret: bundle.inputData.CLIENT_SECRET,
        grant_type: 'authorization_code',
        redirect_uri: bundle.inputData.redirect_uri,
      })
      .reply(200, {
        access_token: 'a_token',
        token_type: 'Bearer',
        expires_in: 3600,
        refresh_token: 'a_refresh_token',
        scope: 'all',
      });

    return appTester(
      App.authentication.oauth2Config.getAccessToken,
      bundle
    ).then(result => {
      result.access_token.should.eql('a_token');
      result.refresh_token.should.eql('a_refresh_token');
    });
  });

  it('can refresh the access token', () => {
    const bundle = {
      authData: {
        access_token: 'a_token',
        refresh_token: 'a_refresh_token',
      },
      inputData: {
        BASE_URL: BASE_URL,
        CLIENT_ID: CLIENT_ID,
        CLIENT_SECRET: process.env.CLIENT_SECRET,
        redirect_uri: process.env.REDIRECT_URI,
      },
    };

    nock(BASE_URL, {
      reqheaders: {
        'content-type': ['application/x-www-form-urlencoded'],
      },
    })
      .post(OAUTH_TOKEN_ENDPOINT, {
        client_id: bundle.inputData.CLIENT_ID,
        client_secret: bundle.inputData.CLIENT_SECRET,
        redirect_uri: bundle.inputData.redirect_uri,
        refresh_token: 'a_refresh_token',
        grant_type: 'refresh_token',
      })
      .reply(200, {
        access_token: 'a_new_token',
        token_type: 'Bearer',
        expires_in: 3600,
        refresh_token: 'a_new_refresh_token',
        scope: 'all',
      });

    return appTester(
      App.authentication.oauth2Config.refreshAccessToken,
      bundle
    ).then(result => {
      result.access_token.should.eql('a_new_token');
      result.refresh_token.should.eql('a_new_refresh_token');
    });
  });

  it('includes the access token in future requests', () => {
    const bundle = {
      authData: {
        BASE_URL: BASE_URL,
        access_token: 'a_token',
        refresh_token: 'a_refresh_token',
      },
    };

    nock(BASE_URL, {
      reqheaders: {
        'user-agent': ['Zapier'],
        authorization: [`Bearer ${bundle.authData.access_token}`],
        'accept-encoding': ['gzip,deflate'],
        connection: ['close'],
        accept: ['application/json'],
      },
    })
      .get(OAUTH_TEST_ENDPOINT)
      .reply(
        200,
        JSON.stringify({
          message: 'Mustermann',
        })
      );

    return appTester(App.authentication.test, bundle).then(result => {
      result.message.should.eql('Mustermann');
    });
  });
});
